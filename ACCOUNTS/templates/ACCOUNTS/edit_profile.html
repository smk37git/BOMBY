{% extends 'MAIN/base.html' %}
{% load static %}

{% block extra_css %}
    <link rel="stylesheet" href="{% static 'css/edit_profile.css' %}">
{% endblock %}

{% block background %}
    {% include 'MAIN/base_background.html' %}
{% endblock %}

{% block content %}
<div class="profile-header">
    <h1 class="edit_profile-title" style="margin-bottom: -20px;">Edit Profile</h1>
</div>
<div class="edit_profile-container">
    <!-- Messages -->
    {% if messages %}
    <div class="messages">
        {% for message in messages %}
            {% if 'order' not in message|lower and 'created' not in message|lower and 'activated' not in message|lower and 'deactivated' not in message|lower and 'payment' not in message|lower %}
                <div class="message {% if message.tags %}{{ message.tags }}{% endif %}">
                    {{ message }}
                </div>
            {% endif %}
        {% endfor %}
    </div>
    {% endif %}
    
    <form method="post" enctype="multipart/form-data" class="edit-profile-form">
        {% csrf_token %}
        <div class="profile-content">
            
            <!-- Left Panel -->
            <div class="profile-section">
                <div class="section-header">
                    <h2>Profile Picture</h2>
                </div>
                
                <div class="profile-picture-section">
                    <div class="profile-picture-container">
                        {% if user.profile_picture and not profile_pic_error %}
                            <img src="{{ user.profile_picture.url }}" alt="Profile Picture" class="edit_current-profile-picture" id="profile-preview" onerror="this.style.display='none'; document.getElementById('profile-placeholder').style.display='flex';">
                            <div class="profile-picture-placeholder" id="profile-placeholder" style="display: none;">
                                <i class="fas fa-user"></i>
                            </div>
                        {% else %}
                            <div class="profile-picture-placeholder" id="profile-placeholder">
                                <i class="fas fa-user"></i>
                            </div>
                            <img src="" alt="Profile Preview" class="edit_current-profile-picture" id="profile-preview" style="display: none;">
                        {% endif %}
                    </div>
                    
                    <!-- Photo operations container -->
                    <div class="buttons-container photo-container">
                        <h3 class="container-title">Update Photo</h3>
                        <div class="upload-info">
                            <div class="info-row">
                                <div class="info-label" style="white-space: nowrap;">Max size: 5MB / 800×800px recommended</div>
                            </div>
                        </div>
                        <div class="action-buttons">
                            <label for="{{ form.profile_picture.id_for_label }}" class="action-button">
                                <i class="fas fa-camera" style="color: white;"></i>
                                <span style="color: white;">Choose Photo</span>
                            </label>
                            <button type="button" id="clear-photo-btn" class="clear-photo-btn" {% if not user.profile_picture %}style="display: none;"{% endif %}>
                                <i class="fas fa-times"></i>
                                <span>Clear</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Profile operations container -->
                    <div class="buttons-container profile-container">
                        <h3 class="container-title">Profile Operations</h3>
                        <div class="action-buttons save-buttons">
                            <a href="{% url 'ACCOUNTS:account' %}" class="action-button">
                                <i class="fas fa-arrow-left"></i> Back to Account
                            </a>
                            <button type="submit" class="action-button">
                                <i class="fas fa-save"></i> Save Changes
                            </button>
                        </div>
                    </div>
                
                    <!-- Keep the form field but hide the display section -->
                    <div style="display:none;">
                        {{ form.profile_picture }}
                        <input type="hidden" name="clear_picture" id="clear-picture-input" value="false">
                
                        <!-- This hides the "Currently:" text and filename -->
                        <div class="currently-info">
                            Currently: {{ user.profile_picture.name }}
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel -->
            <div class="profile-section">
                <div class="section-header">
                    <h2>Social Links</h2>
                </div>
                
                <div class="form-group">
                    <label for="{{ form.youtube_link_1.id_for_label }}">
                        <i class="fab fa-youtube"></i> YouTube Link 1
                    </label>
                    <div class="form-input">
                        {{ form.youtube_link_1 }}
                    </div>
                    <div class="validation-popup" id="youtube-validation-popup"></div>
                    {% if form.youtube_link_1.errors %}
                        <div class="messages">
                            <p class="message error">{{ form.youtube_link_1.errors }}</p>
                        </div>
                    {% endif %}
                </div>

                <div class="form-group">
                    <label for="{{ form.youtube_link_2.id_for_label }}">
                        <i class="fab fa-youtube"></i> YouTube Link 2
                    </label>
                    <div class="form-input">
                        {{ form.youtube_link_2 }}
                    </div>
                    <div class="validation-popup" id="youtube-validation-popup"></div>
                    {% if form.youtube_link_2.errors %}
                        <div class="messages">
                            <p class="message error">{{ form.youtube_link_2.errors }}</p>
                        </div>
                    {% endif %}
                </div>
                
                <div class="form-group">
                    <label for="{{ form.twitch_link.id_for_label }}">
                        <i class="fab fa-twitch"></i> Twitch Link
                    </label>
                    {{ form.twitch_link }}
                    <div class="validation-popup" id="twitch-validation-popup"></div>
                    {% if form.twitch_link.errors %}
                        <div class="error-message">{{ form.twitch_link.errors }}</div>
                    {% endif %}
                </div>

                <div class="form-group">
                    <label for="{{ form.github_link.id_for_label }}">
                        <i class="fab fa-github"></i> GitHub Link
                    </label>
                    {{ form.github_link }}
                    <div class="validation-popup" id="github-validation-popup"></div>
                    {% if form.github_link.errors %}
                        <div class="error-message">{{ form.github_link.errors }}</div>
                    {% endif %}
                </div>
                
                <div class="form-group">
                    <label for="{{ form.twitter_link.id_for_label }}">
                        <i class="fab fa-twitter"></i> X (Twitter) Link
                    </label>
                    {{ form.twitter_link }}
                    <div class="validation-popup" id="twitter-validation-popup"></div>
                    {% if form.twitter_link.errors %}
                        <div class="error-message">{{ form.twitter_link.errors }}</div>
                    {% endif %}
                </div>
                
                <div class="form-group">
                    <label for="{{ form.kick_link.id_for_label }}">
                        <i class="fas fa-gamepad"></i> Kick Link
                    </label>
                    {{ form.kick_link }}
                    <div class="validation-popup" id="kick-validation-popup"></div>
                    {% if form.kick_link.errors %}
                        <div class="error-message">{{ form.kick_link.errors }}</div>
                    {% endif %}
                </div>
                
                <div class="form-group">
                    <label for="{{ form.instagram_link.id_for_label }}">
                        <i class="fab fa-instagram"></i> Instagram Link
                    </label>
                    {{ form.instagram_link }}
                    <div class="validation-popup" id="instagram-validation-popup"></div>
                    {% if form.instagram_link.errors %}
                        <div class="error-message">{{ form.instagram_link.errors }}</div>
                    {% endif %}
                </div>

                <div class="form-group">
                    <label for="id_bio">Bio</label>
                    <textarea name="bio" id="id_bio" class="form-control" rows="5" maxlength="500">{{ form.bio.value|default_if_none:'' }}</textarea>
                    <small class="form-text text-muted">Share a little about yourself. This will be visible on your public profile.</small>
                    <small class="form-text text-muted">
                        <span id="charCount">0</span>/500 characters
                    </small>
                    
                    <!-- Error message container -->
                    {% if form.bio.errors %}
                    <div id="bio-error-container" class="bio-error">
                        {{ form.bio.errors.0 }}
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </form>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Bio character counter
        const bioField = document.getElementById('id_bio');
        const charCount = document.getElementById('charCount');
        const bioValidationMessage = document.getElementById('bioValidationMessage');
        
        // Initial count
        charCount.textContent = bioField.value.length;
        
        // Update count and reset validation on input
        bioField.addEventListener('input', function() {
            // Update character count
            charCount.textContent = this.value.length;
            
            // Change color when approaching limit
            if (this.value.length > 400) {
                charCount.style.color = '#ff9900';
            } else if (this.value.length > 450) {
                charCount.style.color = '#ff0000';
            } else {
                charCount.style.color = '';
            }
            
            // Hide validation message when user starts typing
            if (bioValidationMessage) {
                bioValidationMessage.style.display = 'none';
            }
        });

        const bioErrorContainer = document.getElementById('bio-error-container');
        if (bioErrorContainer) {
            // Set a timeout to fade out the error message after 5 seconds
            setTimeout(() => {
                bioErrorContainer.classList.add('fading');
                
                // Hide after transition completes
                setTimeout(() => {
                    bioErrorContainer.style.display = 'none';
                }, 500);
            }, 4500);
            
            // Also hide on input in the bio field
            document.getElementById('id_bio').addEventListener('input', function() {
                bioErrorContainer.classList.add('fading');
                setTimeout(() => {
                    bioErrorContainer.style.display = 'none';
                }, 500);
            });
        }

        // Profile picture handling
        const fileInput = document.getElementById('{{ form.profile_picture.id_for_label }}');
        const previewImg = document.getElementById('profile-preview');
        const placeholder = document.getElementById('profile-placeholder');
        const clearBtn = document.getElementById('clear-photo-btn');
        const clearInput = document.getElementById('clear-picture-input');
        const maxSize = 10 * 1024 * 1024; // 10MB in bytes
        const maxWidth = 800;
        const maxHeight = 800;
        
        // Show/hide clear button based on whether profile picture exists
        if (previewImg && previewImg.src && previewImg.src !== window.location.href) {
            if (clearBtn) {
                clearBtn.style.display = 'inline-flex';
            }
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            previewImg.style.display = 'block';
        } else {
            if (clearBtn) {
                clearBtn.style.display = 'none';
            }
            if (placeholder) {
                placeholder.style.display = 'flex';
            }
            if (previewImg) {
                previewImg.style.display = 'none';
            }
        }
        
        if (clearBtn) {
            clearBtn.addEventListener('click', function() {
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
                previewImg.style.display = 'none';
                previewImg.src = '';
                fileInput.value = '';
                clearInput.value = 'true';
                clearBtn.style.display = 'none';
            });
        }
        
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            
            if (!file) return;
            
            // Check file size
            if (file.size > maxSize) {
                alert('File is too large. Maximum size is 10MB.');
                fileInput.value = '';
                return;
            }
            
            // Check file type
            const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
            if (!validTypes.includes(file.type)) {
                alert('Invalid file type. Please upload a JPEG, PNG, or GIF image.');
                fileInput.value = '';
                return;
            }
            
            // Preview the image
            const reader = new FileReader();
            reader.onload = function(e) {
                // Create temp image to check dimensions
                const img = new Image();
                img.onload = function() {
                    // Check if dimensions need resizing
                    if (img.width > maxWidth || img.height > maxHeight) {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        
                        // Calculate new dimensions while maintaining aspect ratio
                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Convert to file and update preview
                        previewImg.src = canvas.toDataURL(file.type);
                        
                        // Optional: Convert canvas image to Blob for form submission
                        canvas.toBlob(function(blob) {
                            // Create a new File object
                            const resizedFile = new File([blob], file.name, {
                                type: file.type,
                                lastModified: new Date().getTime()
                            });
                            
                            // Replace the original file with resized one (requires custom handling)
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(resizedFile);
                            fileInput.files = dataTransfer.files;
                        }, file.type);
                    } else {
                        previewImg.src = e.target.result;
                    }
                    
                    if (placeholder) {
                        placeholder.style.display = 'none';
                    }
                    previewImg.style.display = 'block';
                    if (clearBtn) {
                        clearBtn.style.display = 'inline-flex';
                    }
                    clearInput.value = 'false';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Social link validation
        const socialLinks = [
            { 
                input: document.getElementById('id_youtube_link_1'), 
                popup: document.getElementById('youtube-validation-popup'),
                regex: /^https?:\/\/(www\.)?(youtube\.com\/(channel\/|c\/|@|user\/)|youtu\.be\/)/
            },
            { 
                input: document.getElementById('id_youtube_link_2'), 
                popup: document.getElementById('youtube-validation-popup'),
                regex: /^https?:\/\/(www\.)?(youtube\.com\/(channel\/|c\/|@|user\/)|youtu\.be\/)/
            },
            { 
                input: document.getElementById('id_twitch_link'), 
                popup: document.getElementById('twitch-validation-popup'),
                regex: /^https?:\/\/(www\.)?(twitch\.tv\/)/
            },
            { 
                input: document.getElementById('id_github_link'), 
                popup: document.getElementById('github-validation-popup'),
                regex: /^https?:\/\/(www\.)?(github\.com\/)/
            },
            { 
                input: document.getElementById('id_twitter_link'), 
                popup: document.getElementById('twitter-validation-popup'),
                regex: /^https?:\/\/(www\.)?(x\.com\/|twitter\.com\/)/
            },
            { 
                input: document.getElementById('id_kick_link'), 
                popup: document.getElementById('kick-validation-popup'),
                regex: /^https?:\/\/(www\.)?(kick\.com\/)/
            },
            { 
                input: document.getElementById('id_instagram_link'), 
                popup: document.getElementById('instagram-validation-popup'),
                regex: /^https?:\/\/(www\.)?(instagram\.com\/)/
            }
        ];

        socialLinks.forEach(link => {
            link.input.addEventListener('input', function() {
                const value = this.value.trim();
                const popup = link.popup;

                if (value && !link.regex.test(value)) {
                    popup.textContent = 'Invalid link format';
                    popup.style.padding = '10px 15px';
                    popup.style.marginTop = '10px';
                    popup.style.marginBottom = '10px';
                    popup.style.borderRadius = '8px';
                    popup.style.borderLeft = '4px solid #dc3545';
                    popup.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                    popup.style.backgroundColor = '#37000556';
                    popup.style.color = 'ffffff';
                    popup.style.position = 'relative';
                    popup.style.opacity = '1';
                    popup.style.transition = 'opacity 0.5s ease';
                    popup.style.display = 'block';

                } else {
                    popup.textContent = '';
                    popup.style.display = 'none';
                }
            });
        });
    });

    // Elements
    const fileInput = document.getElementById('{{ form.profile_picture.id_for_label }}');
    const previewImg = document.getElementById('profile-preview');
    const placeholder = document.getElementById('profile-placeholder');
    const clearBtn = document.getElementById('clear-photo-btn');
    const clearInput = document.getElementById('clear-picture-input');
    
    // Create modal elements for cropping
    const cropperModal = document.createElement('div');
    cropperModal.className = 'cropper-modal';
    cropperModal.innerHTML = `
        <div class="cropper-container">
            <div class="cropper-header">
                <h2>Crop & rotate</h2>
                <button type="button" class="close-cropper">×</button>
            </div>
            <div class="cropper-content">
                <div class="image-container">
                    <img id="crop-image" src="">
                </div>
                <div class="cropper-actions">
                    <button type="button" class="rotate-btn">
                        <i class="fas fa-sync-alt"></i> Rotate
                    </button>
                    <button type="button" class="apply-crop">Next</button>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(cropperModal);
    
    // Style for the cropper
    const style = document.createElement('style');
    style.textContent = `
        .cropper-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            overflow: auto;
        }
        
        .cropper-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            color: white;
        }
        
        .cropper-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .cropper-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }
        
        .close-cropper {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
        }
        
        .cropper-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .image-container {
            position: relative;
            max-width: 90%;
            max-height: 70vh;
            margin: 0 auto;
        }
        
        #crop-image {
            display: block;
            max-width: 100%;
            max-height: 70vh;
        }
        
        .cropper-actions {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-top: 20px;
        }
        
        .rotate-btn {
            background-color: #333;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .apply-crop {
            background-color: #7289DA;
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .crop-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid white;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7);
            cursor: move;
            z-index: 1;
        }
        
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            z-index: 2;
        }
        
        .resize-handle.nw {
            top: -5px;
            left: -5px;
            cursor: nwse-resize;
        }
        
        .resize-handle.ne {
            top: -5px;
            right: -5px;
            cursor: nesw-resize;
        }
        
        .resize-handle.sw {
            bottom: -5px;
            left: -5px;
            cursor: nesw-resize;
        }
        
        .resize-handle.se {
            bottom: -5px;
            right: -5px;
            cursor: nwse-resize;
        }
        
        @media (max-width: 768px) {
            .cropper-actions {
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }
            
            .image-container {
                max-height: 60vh;
            }
            
            #crop-image {
                max-height: 60vh;
            }
        }
    `;
    document.head.appendChild(style);
    
    // Cropper elements
    const cropperModalEl = document.querySelector('.cropper-modal');
    const closeCropperBtn = document.querySelector('.close-cropper');
    const applyBtn = document.querySelector('.apply-crop');
    const rotateBtn = document.querySelector('.rotate-btn');
    const cropImage = document.getElementById('crop-image');
    
    // Cropper variables
    let cropBox;
    let currentRotation = 0;
    let aspectRatio = 1; // 1:1 for profile pictures
    
    // Open cropper when file is selected
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        
        if (!file) return;
        
        // Check file size
        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            alert('File is too large. Maximum size is 10MB.');
            fileInput.value = '';
            return;
        }
        
        // Check file type
        const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
        if (!validTypes.includes(file.type)) {
            alert('Invalid file type. Please upload a JPEG, PNG, or GIF image.');
            fileInput.value = '';
            return;
        }
        
        // Show cropper with the selected image
        const reader = new FileReader();
        reader.onload = function(e) {
            cropImage.src = e.target.result;
            
            // Reset rotation
            currentRotation = 0;
            cropImage.style.transform = `rotate(${currentRotation}deg)`;
            
            // Wait for image to load to create crop box
            cropImage.onload = function() {
                cropperModalEl.style.display = 'block';
                
                // Create crop box after image is loaded
                setupCropBox();
            };
        };
        reader.readAsDataURL(file);
    });
    
    // Create and setup the crop box
    function setupCropBox() {
        // Remove existing crop box if any
        if (cropBox) {
            cropBox.remove();
        }
        
        const imageContainer = document.querySelector('.image-container');
        cropBox = document.createElement('div');
        cropBox.className = 'crop-box';
        
        // Calculate size for crop box (square for profile picture)
        const imgWidth = cropImage.offsetWidth;
        const imgHeight = cropImage.offsetHeight;
        const size = Math.min(imgWidth, imgHeight) * 0.8; // 80% of the smaller dimension
        
        cropBox.style.width = `${size}px`;
        cropBox.style.height = `${size}px`;
        
        // Add resize handles
        const positions = ['nw', 'ne', 'sw', 'se'];
        positions.forEach(pos => {
            const handle = document.createElement('div');
            handle.className = `resize-handle ${pos}`;
            cropBox.appendChild(handle);
        });
        
        imageContainer.appendChild(cropBox);
        
        // Make crop box draggable
        makeDraggable(cropBox);
        
        // Make crop box resizable
        makeResizable(cropBox);
    }
    
    // Make an element draggable
    function makeDraggable(element) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        element.addEventListener('mousedown', dragMouseDown);
        element.addEventListener('touchstart', dragTouchStart, { passive: false });
        
        function dragMouseDown(e) {
            e.preventDefault();
            // Get the mouse cursor position at startup
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.addEventListener('mouseup', closeDragElement);
            document.addEventListener('mousemove', elementDrag);
        }
        
        function dragTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            pos3 = touch.clientX;
            pos4 = touch.clientY;
            document.addEventListener('touchend', closeTouchDragElement);
            document.addEventListener('touchmove', elementTouchDrag, { passive: false });
        }
        
        function elementDrag(e) {
            e.preventDefault();
            // Calculate the new cursor position
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            // Constrain to image boundaries
            const imageRect = cropImage.getBoundingClientRect();
            const cropRect = element.getBoundingClientRect();
            
            let newTop = element.offsetTop - pos2;
            let newLeft = element.offsetLeft - pos1;
            
            // Boundary checks
            if (newTop < 0) newTop = 0;
            if (newLeft < 0) newLeft = 0;
            if (newTop + cropRect.height > imageRect.height) {
                newTop = imageRect.height - cropRect.height;
            }
            if (newLeft + cropRect.width > imageRect.width) {
                newLeft = imageRect.width - cropRect.width;
            }
            
            // Set the element's new position
            element.style.top = newTop + "px";
            element.style.left = newLeft + "px";
        }
        
        function elementTouchDrag(e) {
            e.preventDefault();
            const touch = e.touches[0];
            pos1 = pos3 - touch.clientX;
            pos2 = pos4 - touch.clientY;
            pos3 = touch.clientX;
            pos4 = touch.clientY;
            
            // Constrain to image boundaries
            const imageRect = cropImage.getBoundingClientRect();
            const cropRect = element.getBoundingClientRect();
            
            let newTop = element.offsetTop - pos2;
            let newLeft = element.offsetLeft - pos1;
            
            // Boundary checks
            if (newTop < 0) newTop = 0;
            if (newLeft < 0) newLeft = 0;
            if (newTop + cropRect.height > imageRect.height) {
                newTop = imageRect.height - cropRect.height;
            }
            if (newLeft + cropRect.width > imageRect.width) {
                newLeft = imageRect.width - cropRect.width;
            }
            
            // Set the element's new position
            element.style.top = newTop + "px";
            element.style.left = newLeft + "px";
        }
        
        function closeDragElement() {
            // Stop moving when mouse button is released
            document.removeEventListener('mouseup', closeDragElement);
            document.removeEventListener('mousemove', elementDrag);
        }
        
        function closeTouchDragElement() {
            document.removeEventListener('touchend', closeTouchDragElement);
            document.removeEventListener('touchmove', elementTouchDrag);
        }
    }
    
    // Make an element resizable (maintains aspect ratio)
    function makeResizable(element) {
        const handles = element.querySelectorAll('.resize-handle');
        
        handles.forEach(handle => {
            handle.addEventListener('mousedown', resizeMouseDown);
            handle.addEventListener('touchstart', resizeTouchStart, { passive: false });
        });
        
        function resizeMouseDown(e) {
            e.stopPropagation();
            e.preventDefault();
            
            const handle = e.target;
            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = element.offsetWidth;
            const startHeight = element.offsetHeight;
            const startTop = element.offsetTop;
            const startLeft = element.offsetLeft;
            
            document.addEventListener('mousemove', resizeMove);
            document.addEventListener('mouseup', resizeEnd);
            
            function resizeMove(e) {
                e.preventDefault();
                
                let newWidth, newHeight, newTop, newLeft;
                
                // Calculate new size based on handle position
                if (handle.classList.contains('se')) {
                    newWidth = startWidth + (e.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                } else if (handle.classList.contains('sw')) {
                    newWidth = startWidth - (e.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                    newLeft = startLeft + (startWidth - newWidth);
                } else if (handle.classList.contains('ne')) {
                    newWidth = startWidth + (e.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                    newTop = startTop + (startHeight - newHeight);
                } else if (handle.classList.contains('nw')) {
                    newWidth = startWidth - (e.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                    newTop = startTop + (startHeight - newHeight);
                    newLeft = startLeft + (startWidth - newWidth);
                }
                
                // Apply size constraints
                const minSize = 50;
                const maxSize = cropImage.offsetWidth;
                if (newWidth > minSize && newWidth <= maxSize) {
                    element.style.width = `${newWidth}px`;
                    element.style.height = `${newHeight}px`;
                    
                    if (newTop !== undefined) element.style.top = `${newTop}px`;
                    if (newLeft !== undefined) element.style.left = `${newLeft}px`;
                }
            }
            
            function resizeEnd() {
                document.removeEventListener('mousemove', resizeMove);
                document.removeEventListener('mouseup', resizeEnd);
            }
        }
        
        function resizeTouchStart(e) {
            e.stopPropagation();
            e.preventDefault();
            
            const handle = e.target;
            const touch = e.touches[0];
            const startX = touch.clientX;
            const startY = touch.clientY;
            const startWidth = element.offsetWidth;
            const startHeight = element.offsetHeight;
            const startTop = element.offsetTop;
            const startLeft = element.offsetLeft;
            
            document.addEventListener('touchmove', resizeTouchMove, { passive: false });
            document.addEventListener('touchend', resizeTouchEnd);
            
            function resizeTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                
                let newWidth, newHeight, newTop, newLeft;
                
                // Calculate new size based on handle position
                if (handle.classList.contains('se')) {
                    newWidth = startWidth + (touch.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                } else if (handle.classList.contains('sw')) {
                    newWidth = startWidth - (touch.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                    newLeft = startLeft + (startWidth - newWidth);
                } else if (handle.classList.contains('ne')) {
                    newWidth = startWidth + (touch.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                    newTop = startTop + (startHeight - newHeight);
                } else if (handle.classList.contains('nw')) {
                    newWidth = startWidth - (touch.clientX - startX);
                    newHeight = newWidth / aspectRatio;
                    newTop = startTop + (startHeight - newHeight);
                    newLeft = startLeft + (startWidth - newWidth);
                }
                
                // Apply size constraints
                const minSize = 50;
                const maxSize = cropImage.offsetWidth;
                if (newWidth > minSize && newWidth <= maxSize) {
                    element.style.width = `${newWidth}px`;
                    element.style.height = `${newHeight}px`;
                    
                    if (newTop !== undefined) element.style.top = `${newTop}px`;
                    if (newLeft !== undefined) element.style.left = `${newLeft}px`;
                }
            }
            
            function resizeTouchEnd() {
                document.removeEventListener('touchmove', resizeTouchMove);
                document.removeEventListener('touchend', resizeTouchEnd);
            }
        }
    }
    
    // Close cropper without applying
    closeCropperBtn.addEventListener('click', function() {
        cropperModalEl.style.display = 'none';
        fileInput.value = '';
    });
    
    // Rotate image
    rotateBtn.addEventListener('click', function() {
        currentRotation = (currentRotation + 90) % 360;
        cropImage.style.transform = `rotate(${currentRotation}deg)`;
        
        // When rotating 90 or 270 degrees, we need to readjust the crop box
        if (currentRotation === 90 || currentRotation === 270) {
            // If we need to handle non-square images with different orientations
            setupCropBox();
        }
    });
    
    // Apply crop and close the modal
    applyBtn.addEventListener('click', function() {
        // Get crop dimensions and position relative to the image
        const imgRect = cropImage.getBoundingClientRect();
        const cropRect = cropBox.getBoundingClientRect();
        
        // Calculate crop coordinates
        const scaleX = cropImage.naturalWidth / imgRect.width;
        const scaleY = cropImage.naturalHeight / imgRect.height;
        
        // Calculate based on current position of the crop box relative to the image
        const cropLeft = (cropRect.left - imgRect.left) * scaleX;
        const cropTop = (cropRect.top - imgRect.top) * scaleY;
        const cropWidth = cropRect.width * scaleX;
        const cropHeight = cropRect.height * scaleY;
        
        // Create canvas for cropping
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        
        // Create a temporary image to handle rotation and cropping
        const tempImg = new Image();
        tempImg.src = cropImage.src;
        
        tempImg.onload = function() {
            if (currentRotation !== 0) {
                // If rotated, we need to adjust the crop coordinates
                switch(currentRotation) {
                    case 90:
                        // Convert coordinates for 90 degree rotation
                        canvas.width = cropHeight;
                        canvas.height = cropWidth;
                        ctx.rotate(Math.PI / 2);
                        ctx.translate(0, -canvas.width);
                        ctx.drawImage(
                            tempImg,
                            cropTop, // x becomes y
                            tempImg.width - cropLeft - cropWidth, // y becomes inverted x
                            cropHeight,
                            cropWidth
                        );
                        break;
                    case 180:
                        ctx.rotate(Math.PI);
                        ctx.translate(-canvas.width, -canvas.height);
                        ctx.drawImage(
                            tempImg,
                            tempImg.width - cropLeft - cropWidth,
                            tempImg.height - cropTop - cropHeight,
                            cropWidth,
                            cropHeight,
                            0, 0, cropWidth, cropHeight
                        );
                        break;
                    case 270:
                        canvas.width = cropHeight;
                        canvas.height = cropWidth;
                        ctx.rotate(-Math.PI / 2);
                        ctx.translate(-canvas.height, 0);
                        ctx.drawImage(
                            tempImg,
                            tempImg.width - cropTop - cropHeight,
                            cropLeft,
                            cropHeight,
                            cropWidth
                        );
                        break;
                }
            } else {
                // No rotation, just crop
                ctx.drawImage(
                    tempImg,
                    cropLeft, cropTop, cropWidth, cropHeight,
                    0, 0, cropWidth, cropHeight
                );
            }
            
            // Convert canvas to blob and update profile picture
            canvas.toBlob(function(blob) {
                // Create a new File object
                const croppedFile = new File([blob], 'profile_picture.png', {
                    type: 'image/png',
                    lastModified: new Date().getTime()
                });
                
                // Create a data transfer and set it to the file input
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(croppedFile);
                fileInput.files = dataTransfer.files;
                
                // Update preview
                const croppedURL = URL.createObjectURL(blob);
                previewImg.src = croppedURL;
                
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
                previewImg.style.display = 'block';
                if (clearBtn) {
                    clearBtn.style.display = 'inline-flex';
                }
                clearInput.value = 'false';
                
                // Close the cropper modal
                cropperModalEl.style.display = 'none';
            }, 'image/png');
        };
    });
</script>
{% endblock %}