{% extends 'MAIN/base.html' %}
{% load static %}

{% block title %}FuzeOBS Project - Streaming Toolkit Software | BOMBY{% endblock %}
{% block description %}Software to help creators get setup and running within minutes. Offers automatic hardware detection, auto-configured settings, real-time widgets, and AI-Enhancements with a personal assistant to use 24/7.{% endblock %}
{% block og_title %}FuzeOBS Project - Streaming Toolkit Software | BOMBY{% endblock %}
{% block og_description %}Software to help creators get setup and running within minutes. Offers automatic hardware detection, auto-configured settings, real-time widgets, and AI-Enhancements with a personal assistant to use 24/7.{% endblock %}
{% block og_url %}https://bomby.us/portfolio/fuzeobs-project/{% endblock %}

{% block extra_css %}
    <link rel="stylesheet" href="{% static 'css/bomby_page.css' %}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
{% endblock %}

{% block background %}
    {% include 'MAIN/base_background.html' %}
{% endblock %}

{% block content %}
    <div class="project-container" style="padding-top: 75px;">
        <!-- Horizontal Split Hero Section -->
        <section class="hero-split">
            <!-- Left Side - Hero Content -->
            <div class="hero-content-side">
                <h1 class="project-title">FUZEOBS PROJECT
                </h1>
                <p class="project-author">By Sebastian Main</p>
                <p class="project-brief">
                    From hardware detection to AI assistance, FuzeOBS covers every aspect of your streaming setup.
                </p>
                
                <div class="hero-cta">
                    <a href="{% url 'PORTFOLIO:portfolio' %}" class="hero-button">
                        <i class="fas fa-arrow-left"></i> Back to Portfolio
                    </a>
                    <a href="{% url 'FUZEOBS:fuzeobs' %}" target="_blank" class="hero-button primary">View Live</a>
                </div>
            </div>
            
            <!-- Right Side - Gallery -->
            <div class="hero-gallery-side">
                <div class="project-featured-image">
                    <img src="{% static 'images/fuzeobs_1.png' %}" alt="Project Name" class="featured-image" id="featuredImage">
                </div>
                
                <div class="gallery-thumbnails">
                    <div class="thumbnail active" data-image="{% static 'images/fuzeobs_1.png' %}">
                        <img src="{% static 'images/fuzeobs_1.png' %}" alt="Main Project Image">
                    </div>
                    <div class="thumbnail" data-image="{% static 'images/fuzeobs_2.png' %}">
                        <img src="{% static 'images/fuzeobs_2.png' %}" alt="Gallery Image 1">
                    </div>
                    <div class="thumbnail" data-image="{% static 'images/fuzeobs_3.png' %}">
                        <img src="{% static 'images/fuzeobs_3.png' %}" alt="Gallery Image 2">
                    </div>
                    <div class="thumbnail" data-image="{% static 'images/fuzeobs_4.png' %}">
                        <img src="{% static 'images/fuzeobs_4.png' %}" alt="Gallery Image 3">
                    </div>
                    <div class="thumbnail" data-image="{% static 'images/fuzeobs_5.png' %}">
                        <img src="{% static 'images/fuzeobs_5.png' %}" alt="Gallery Image 4">
                    </div>
                </div>
            </div>
        </section>

        <!-- Main Content -->
        <div class="project-content-steam" style="margin-top: -100px;">
            <!-- Overview Section -->
            <section class="content-section" id="overview">
                <div class="section-header">
                    <h2 class="section-title" style="margin-top: 100px;">Project Overview</h2>
                    <p class="section-subtitle">A detailed look at the purpose and approach of this project</p>
                </div>
                
                <div class="project-info-grid">
                    <div class="info-card">
                        <h3 class="info-card-title">The Project</h3>
                        <div class="info-card-content">
                            <p>
                                I created FuzeOBS out of frustration with how difficult it is for new streamers to get OBS configured properly.
                                There are countless tutorials and guides online, but none of them account for the fact that everyone's hardware is different.
                                What works for someone with an RTX 4090 isn't going to work for someone on integrated graphics. I wanted to build a tool
                                that could detect your system, understand your hardware limitations, and generate the perfect OBS configuration for you automatically.
                                <br></br>

                                Beyond just settings, I wanted FuzeOBS to be an all-in-one streaming toolkit. From scene templates, integrated widget configuration, performance benchmarking,
                                and an AI assistant that can answer any streaming question, I wanted creators to have everything they need in one place
                                so they could focus on what matters which is actually creating content.
                            </p>
                            
                            <div class="info-stats">
                                <div class="info-stat">
                                    <div class="stat-label">Date</div>
                                    <div class="stat-value">October 2025 - Present</div>
                                </div>
                                <div class="info-stat">
                                    <div class="stat-label">Category</div>
                                    <div class="stat-value">Desktop Application</div>
                                </div>
                                <div class="info-stat">
                                    <div class="stat-label">Role</div>
                                    <div class="stat-value">Solo Developer</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="info-card">
                        <h3 class="info-card-title">My Approach</h3>
                        <div class="info-card-content">
                            <p>
                                I started by breaking down exactly what a new streamer needs to go through to get up and running. The answer was a lot.
                                Hardware detection, encoder selection, bitrate calculations, scene setup, audio routing, etc. It's overwhelming for someone
                                who just wants to hit "Go Live". So I mapped out every step and figured out how to automate each one.
                                <br></br>

                                I built the backend in Python with Flask handling the API layer and PyWebView wrapping it into a native desktop app.
                                The frontend is a full Next.js React application that communicates with the backend for everything from system detection
                                to OBS WebSocket control. My focus was making it feel like a real desktop application while keeping the development
                                workflow modern and maintainable.
                            </p>
                            
                            <div class="info-stats">
                                <div class="info-stat">
                                    <div class="stat-label">Tech Stack</div>
                                    <div class="stat-value">Python, Flask, TypeScript, React, Next.js, PyWebView, OBS WebSocket</div>
                                </div>
                                <div class="info-stat">
                                    <div class="stat-label">Timeline</div>
                                    <div class="stat-value">5+ Months (Ongoing)</div>
                                </div>
                                <div class="info-stat">
                                    <div class="stat-label">Purpose</div>
                                    <div class="stat-value">Automate OBS setup and empower creators with intelligent tools</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- Technical Details Section -->
            <section class="content-section" id="technical">
                <div class="section-header">
                    <h2 class="section-title" style="margin-top: -50px;">Technical Details</h2>
                    <p class="section-subtitle">A deeper look at the development process and implementation</p>
                </div>
                
                <div class="tech-details">
                    <h3>Development Process</h3>
                    <p>
                        I began by building the system detection engine. This was the foundation of the entire app. if I couldn't accurately
                        identify a user's CPU, GPU, RAM, and peripherals, nothing else would work. I put together platform-specific detection for
                        Windows, macOS, and Linux covering everything from NVIDIA GPU generations to Intel QSV capabilities to Apple Silicon chips.
                        The detector even identifies webcam resolutions by querying DirectShow, AVFoundation, or v4l2 depending on the platform.
                        <br></br>

                        From there I built the settings generator. Based on your detected hardware, it selects
                        the optimal encoder (NVENC, AMD AMF, QSV, or x264), calculates the right bitrate for your chosen platform, and picks
                        encoder presets that match your quality preference. I created five quality tiers from "Max Performance" to "Max Quality"
                        with specific encoder configurations for each one. The system even knows when to fall back to x264, like when you have
                        an older GPU but a beefy CPU.
                        <br></br>

                        Next came the OBS integration. FuzeOBS generates complete OBS profile files and scene collections, then connects via
                        WebSocket to apply them live. I built a scene template system that pulls templates from my Django backend on bomby.us
                        and injects the user's actual devices. Things like their specific webcam, microphone, and audio output are put directly into the scenes.
                        <br></br>

                        I also built a full performance monitoring system that connects to OBS via WebSocket and collects real-time stats on
                        CPU usage, GPU load, FPS stability, dropped frames, encoding lag, and network congestion. It grades your stream
                        performance from A to F across every metric and identifies exactly what's causing issues. On top of all that,
                        I integrated an AI chat assistant, a user account system with Google OAuth, TikTok OAuth, an auto-updater that handles
                        Windows .exe, macOS .dmg, and Linux .deb installs, and profile management so users can save and swap configurations.
                        The app also features 10 distinct tabs covering deployment, setup, extras, and AI enhancements with built-in stream
                        widgets like alerts, chat boxes, viewer counts, goal bars, and donation overlays that users can inject directly into their scenes.
                        <br></br>
                        
                        All together, FuzeOBS takes what used to be hours of research and configuration and turns it into a few clicks.
                    </p>
                    
                    <h3>Technical Challenges</h3>
                    <p>
                        The biggest challenge was making this app truly cross-platform. PyWebView behaves differently on every OS. Windows
                        uses EdgeChromium, macOS uses WebKit, and Linux needs Qt WebEngine. On Linux specifically, I had to run Flask
                        in a separate thread and implement a health-check polling system because PyWebView can't serve Flask directly
                        like it does on Windows and macOS. Getting the startup sequence right so the window doesn't open before the
                        server is ready took a lot of trial and error.
                        <br></br>

                        Another major hurdle was webcam detection. Every platform uses a completely different API. DirectShow on Windows,
                        AVFoundation on macOS, and v4l2 on Linux. I had to write separate enumerators for each one that not only find
                        the devices but also query their actual supported resolutions so I can inject the correct settings into OBS scenes.
                        On Windows alone I have three fallback methods (pygrabber, FFmpeg, and WMI) because no single approach works reliably
                        on every machine.
                        <br></br>

                        The auto-updater was also a beast. On Windows I generate a batch script that kills the running app, installs silently,
                        and relaunches. On macOS I mount the DMG, copy the .app with ditto to preserve code signatures, re-sign it ad-hoc,
                        remove quarantine flags, and then launch. All from a detached bash script that survives the parent process dying.
                        Each platform had its own set of edge cases that took real persistence to iron out.
                    </p>
                    
                    <pre>
// Encoder Selection Logic
def _select_encoder(self, quality_preference: str) -> str:
    gpu_encoder = self.specs['gpu']['encoder_available']
    if not gpu_encoder:
        return 'x264'

    gpu_gen = self.specs['gpu'].get('generation', {})
    cpu_cores = self.specs['cpu']['logical_cores']

    if gpu_encoder == 'nvenc':
        nvenc_gen = gpu_gen.get('nvenc_gen', 3)
        return self._apply_encoder_rule(
            NVENC_RULES.get(nvenc_gen),
            cpu_cores, quality_preference, 'nvenc_h264'
        )
    return 'x264'
</pre>
                    
                    <h3>Key Features</h3>
                    <ul>
                        <li>Automatic Hardware Detection and Intelligent Encoder Selection</li>
                        <li>One-Click OBS Configuration with Platform-Specific Optimization</li>
                        <li>Customizable Widgets for all Supported Platforms</li>
                        <li>Real-Time Performance Monitoring with A-F Grading System</li>
                        <li>AI-Powered Streaming Assistant with Benchmarking Analysis</li>
                    </ul>
                    
                    <h3>Lessons Learned</h3>
                    <p>
                        FuzeOBS taught me more than any other project I've worked on. Building a cross-platform desktop application
                        forced me to understand how each operating system handles things differently. From process management to
                        file paths to hardware APIs. I gained a deep understanding of video encoding, OBS internals, and how
                        streaming actually works under the hood.
                        <br></br>

                        More than anything, this project taught me the importance of building with the user in mind. Every feature
                        I added was driven by the question "what would a new streamer struggle with?" and that mindset kept the
                        project focused and purposeful. I'm proud of what FuzeOBS has become and I'm excited to keep building on it.
                    </p>
                </div>
            </section>
            
            <!-- Contact CTA Section -->
            <section class="contact-cta">
                <div class="cta-content">
                    <h2>INTERESTED IN MY WORK?</h2>
                    <p>I'm available for consulting projects and would love to discuss how I can help bring your ideas to life.</p>
                    <a href="{% url 'MAIN:contact' %}" class="cta-button">GET IN TOUCH</a>
                </div>
            </section>
        </div>

        <!-- Lightbox Modal -->
        <div id="lightboxModal" class="lightbox-modal">
            <span class="close-modal">&times;</span>
            <div class="lightbox-content">
                <img id="lightboxImage" src="" alt="Lightbox Image">
                <div class="lightbox-nav">
                    <button id="prevButton" class="nav-button"><i class="fas fa-chevron-left"></i></button>
                    <button id="nextButton" class="nav-button"><i class="fas fa-chevron-right"></i></button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script>
        AOS.init({
            duration: 800,
            offset: 100,
            once: true
        });
        
        document.addEventListener('DOMContentLoaded', function() {

            // Full screen featured image
            initLightbox();

            // Make thumbnails clickable on mobile
            const featuredImage = document.getElementById('featuredImage');
            const thumbnails = document.querySelectorAll('.thumbnail');
            
            const inactiveThumbnails = document.querySelectorAll('.thumbnail:not(.active)');
            inactiveThumbnails.forEach(thumb => {
                thumb.style.border = '2px solid #444';
            });
            
            thumbnails.forEach(thumb => {
                thumb.addEventListener('click', function() {
                    featuredImage.src = this.dataset.image;
                    thumbnails.forEach(t => {
                        t.classList.remove('active');
                        t.style.border = '2px solid #444';
                    });
                    this.classList.add('active');
                    this.style.border = '2px solid #ffffff';
                });
            });
            
            function handleThumbClick(e) {
                // Prevent default behavior
                e.preventDefault();
                e.stopPropagation();
                
                // Get the thumbnail element
                const thumb = this;
                
                // Update image
                const imgSrc = thumb.getAttribute('data-image');
                featuredImage.src = imgSrc;
                
                // Update active state
                thumbnails.forEach(t => t.classList.remove('active'));
                thumb.classList.add('active');
                
                return false;
            }
            
            // Scroll animation
            const contentSections = document.querySelectorAll('.content-section');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 });
            
            contentSections.forEach(section => observer.observe(section));

            // Lightbox functionality
            function initLightbox() {
                const modal = document.getElementById('lightboxModal');
                const modalImg = document.getElementById('lightboxImage');
                const closeBtn = document.querySelector('.close-modal');
                const prevBtn = document.getElementById('prevButton');
                const nextBtn = document.getElementById('nextButton');
                const featuredImage = document.getElementById('featuredImage');
                const thumbnails = document.querySelectorAll('.thumbnail');
                
                // Current image index
                let currentIndex = 0;
                
                // Get all image sources from thumbnails
                const imageSources = Array.from(thumbnails).map(thumb => thumb.dataset.image);
                
                // Open lightbox when clicking on featured image
                featuredImage.addEventListener('click', function() {
                    modal.style.display = 'block';
                    modalImg.src = this.src;
                    
                    // Find the current index
                    currentIndex = imageSources.indexOf(this.src);
                    
                    // Disable scrolling on body
                    document.body.style.overflow = 'hidden';
                });
                
                // Close the lightbox
                closeBtn.addEventListener('click', function() {
                    modal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                });
                
                // Close on click outside the image
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                        document.body.style.overflow = 'auto';
                    }
                });
                
                // Previous image
                prevBtn.addEventListener('click', function() {
                    currentIndex = (currentIndex - 1 + imageSources.length) % imageSources.length;
                    modalImg.src = imageSources[currentIndex];
                });
                
                // Next image
                nextBtn.addEventListener('click', function() {
                    currentIndex = (currentIndex + 1) % imageSources.length;
                    modalImg.src = imageSources[currentIndex];
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', function(e) {
                    if (modal.style.display === 'block') {
                        if (e.key === 'ArrowLeft') {
                            prevBtn.click();
                        } else if (e.key === 'ArrowRight') {
                            nextBtn.click();
                        } else if (e.key === 'Escape') {
                            closeBtn.click();
                        }
                    }
                });
            }
        });
    </script>
{% endblock %}